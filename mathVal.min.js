/*
Description: Validate a logic expression, show the error messages and decorate the charactes that cause the errors
Author: Thai.Tran
Company: Nexcel Solution Corp.

  - using: expVal.validateLogicExpession(exp, sep, isCheckChildFormat)
  -  expression = exp, with separate = sep, isCheckChildFormat (default = FALSE): TRUE// it means checking every child logic MUST follow the rule: {V1} or {V1 opt V2}
  -  return "errMsg,exp"
          + Valid: errMsg = "", oldExp // oldEXp : the input exp
          + Invalid: errMsg != "", newExp  // newExp : the exp is formated (inject color, etc...)     

 
*/
var expVal = function () { var t = function (t, r) { this.id = t, this.data = r, this.error = !1 }, r = [], i = !1; return { validateLogicExpession: function (a, e, s) { i = "undefined" != typeof s && null != s ? s : !1; var n = [], o = ["Expression is invalid", "Expression is missing (", "Expression is missing )"], h = [], d = a.split(e); this.buildArrayExp(d); for (var u = 0; u < r.length; ) { var l = r[u]; if (")" != l.data) h.push(new t(l.id, l.data)); else { for (var f = []; h.length > 0 && (p = h.pop(), "(" != p.data); ) f.push(new t(p.id, p.data)); "(" != p.data ? (this.detectError([l]), n.push(1)) : f.length > 0 && (0 == this.isValidLogic(f) && (this.detectError(f), n.push(0)), h.push(new t(-1, "T"))) } u++ } if (h.length > 0) { 0 == this.isValidLogic(h) && (this.detectError(h), n.push(0)); for (var u = 0; u < h.length; u++) { var p = h[u]; "(" == p.data && (this.detectError([p]), n.push(2)) } } return this.getResult(n, o) }, buildArrayExp: function (i) { for (var a = 0; a < i.length; a++) "" != i[a] && r.push(new t(a, i[a].trim())) }, isValidLogic: function (t) { var r = t.length; if (this.isOperator(t[0].data) || this.isOperator(t[r - 1].data)) return !1; for (var i = 0; r - 1 > i; ) { if (")" != t[i].data && "(" != t[i].data) { if (!this.isOperator(t[i].data) && !this.isBoolExp(t[i].data)) return !1; if (this.isOperator(t[i].data) && this.isOperator(t[i + 1].data)) return !1; if (this.isBoolExp(t[i].data) && this.isBoolExp(t[i + 1].data)) return !1 } i++ } return ")" == t[r - 1].data || "(" == t[r - 1].data || this.isOperator(t[r - 1].data) || this.isBoolExp(t[r - 1].data) ? !0 : !1 }, isOperator: function (t) { var r = ["AND", "OR", "XOR", "NOT"]; return r.indexOf(t.toUpperCase()) > -1 }, isBoolExp: function (t) { if (this.isOperator(t)) return !1; if (!i) return !0; var r = [">", "<", "=", ">=", "<="], a = t.split(" "); return 1 != a.length && 3 != a.length ? !1 : (1 != a.length || !this.isOperator(a[0]) && this.isValidCharacter(a[0])) && (3 != a.length || this.isValidCharacter(a[0]) && r.indexOf(a[1]) > -1 && this.isValidCharacter(a[2])) ? !0 : !1 }, isValidCharacter: function (t) { var r = /^[a-zA-Z0-9\/]*$/; return r.test(t) ? !0 : !1 }, detectError: function (t) { for (var i = 0; i < t.length; i++) { for (var a = 0; a < r.length && r[a].id != t[i].id; ) a++; a < r.length && (r[a].error = !0) } }, injectFormat: function () { for (var t = "", i = 0; i < r.length; i++) t += r[i].error ? " <font color='red'>" + r[i].data + "</font>" : " " + r[i].data; return t }, injectErrorMsg: function (t, r) { for (var i = t.reduce(function (t, r) { return t.indexOf(r) < 0 && t.push(r), t }, []), a = "", e = 0; e < i.length; e++) a += r[i[e]] + " , "; return a }, getResult: function (t, i) { var a = this.injectErrorMsg(t, i) + this.injectFormat(); return r = [], a } } } ();